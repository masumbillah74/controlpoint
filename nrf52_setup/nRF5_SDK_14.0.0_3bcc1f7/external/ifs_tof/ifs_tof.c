/*
*Copyright 2017 Fondazione Bruno Kessler
*
*Licensed under the Apache License, Version 2.0 (the "License");
*you may not use this file except in compliance with the License.
*You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
*Unless required by applicable law or agreed to in writing, software
*distributed under the License is distributed on an "AS IS" BASIS,
*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*See the License for the specific language governing permissions and
*limitations under the License.
*
*
* author: Davide Giovanelli 2017 - davigiov88@gmail.com
*/


#include "ifs_tof.h"
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "sdk_config.h"
#include "boards.h"
#include "bsp.h"
#include "bsp_btn_ble.h"
#include "nrf.h"
#include "ble_hci.h"
#include "nordic_common.h"
#include "nrf_gpio.h"
#include "ble_advdata.h"
#include "ble_srv_common.h"
#include "nrf_ble_gatt.h"
#include "app_timer.h"
#include "app_error.h"
#include "ble_conn_params.h"

#include "nrf_gpiote.h"
#include "nrf_drv_ppi.h"
#include "nrf_drv_timer.h"
#include "nrf_drv_gpiote.h"
#include "nrf_egu.h"

#include "nrf_sdh_ble.h"

#define NRF_LOG_MODULE_NAME IFS_TOF
#include "nrf_log.h"
#include "nrf_log_ctrl.h"

#define GET_EGU_INSTANCE(id) 					CONCAT_5(SWI, id, _EGU, id, _IRQn)
#define GET_EGU_IRQN(id)						CONCAT_5(SWI, id, _EGU, id, _IRQHandler)
#define GET_EGU(id)								CONCAT_2(NRF_EGU, id)

#define EGU_IRQn 								GET_EGU_INSTANCE( EGU_INSTANCE )
#define EGU_IRQHandler  						GET_EGU_IRQN( EGU_INSTANCE )
#define EGU 		   		 					GET_EGU( EGU_INSTANCE )

#define GPIO_DEBUG_OUT_PIN_NUMBER 				NRF_GPIO_PIN_MAP(0,3)


const nrf_drv_timer_t TIMER = NRF_DRV_TIMER_INSTANCE(TIMER_INSTANCE);

static bool volatile m_ifs_tof_active = false;
static uint8_t m_number_of_registered_conn_handles = 0;

static volatile bool m_rx_ok = false, m_tx_ok = false, m_rssi_ok = false;
static volatile uint32_t m_rxaddress_evt_ticks_sample = 0, m_radio_freq_sample = 0;
static volatile uint32_t m_access_address_sample;
static int8_t m_rssi_sample;
static volatile uint16_t m_conn_handle_sample;
static volatile uint32_t m_ce_counter = 0; //this will count the overall amount of connection events
static ifs_tof_t * m_p_buff = NULL;

void ifs_tof_on_single_sample_rdy(void);
ifs_tof_t* get_instance_by_conn_handle(uint16_t target_conn_h);

ifs_tof_t* get_first_free_instance(void){
	return get_instance_by_conn_handle(BLE_CONN_HANDLE_INVALID); //a free position is marked with conn_handle == BLE_CONN_HANDLE_INVALID
}

ifs_tof_t* get_instance_by_conn_handle(uint16_t target_conn_h){
	if(m_p_buff == NULL){
		return NULL;
	}
	for(uint8_t i = 0; i < IFT_TOF_MAX_NUM_OF_CENTRAL_LINKS; i++){
		if(m_p_buff[i].conn_handle == target_conn_h){
			return &m_p_buff[i];
		}
	}
	return NULL;
}

void ifs_tof_on_ble_evt(const ble_evt_t * p_ble_evt, void * p_context){

	(void)p_context;

	uint32_t err_code;
	ble_gap_evt_t const * p_gap_evt = &p_ble_evt->evt.gap_evt;
	uint16_t m_conn_handle = p_gap_evt->conn_handle;

	switch (p_ble_evt->header.evt_id) {

	case BLE_GAP_EVT_CONNECTED:
		break;

	case BLE_GAP_EVT_DISCONNECTED:
		break;

#if defined(S140)
	case BLE_GAP_EVT_PHY_UPDATE: {

	}
		break;
#endif

	case BLE_GAP_EVT_RSSI_CHANGED:
		/*
		 * Note: there is no straight forward way for coupling the radio events generated by the radio with a peer (or a connection handle).
		 * Of course if only one connection is present the problem doesn't exist, but when multiple concurrent BLE connections are established
		 * we can measure the ToF but we cannot say which node the measure belongs to.
		 * Here we use the BLE_GAP_EVT_RSSI_CHANGED event to do so. For this we speculate that the BLE_GAP_EVT_RSSI_CHANGED always
		 * refers to the peer of the last ToF sample acquired. This is experimentally confirmed. Anyway when there are many peers
		 * connected with low connection interval values it is not clear if the behavior is reliable or not.
		 */
		//nrf_gpio_pin_toggle(GPIO_DEBUG_OUT_PIN_NUMBER);
		if (m_ifs_tof_active) {
			m_conn_handle_sample = m_conn_handle;
			int8_t api_rssi_sample;
			err_code = sd_ble_gap_rssi_get(m_conn_handle, &api_rssi_sample);
			if (err_code == NRF_SUCCESS && api_rssi_sample == m_rssi_sample) {//we already get the rssi value form the registers. Here just check the two values are the same, if not we cannot couple this event with the ToF value. This of course isn't very reliable, anyway after some test it turns out that it is enough (probably this check can be removed without any effect).
				m_rssi_ok = true;
				ifs_tof_on_single_sample_rdy();
			}

			m_rx_ok = false;
			m_tx_ok = false;
			m_rssi_ok = false;

		}
		nrf_drv_timer_pause(&TIMER);
		nrf_drv_timer_clear(&TIMER);
		break;

	default:
		break;
	}
}

void ifs_tof_on_single_sample_rdy(void) {
	ifs_tof_t* p_ctx = get_instance_by_conn_handle(m_conn_handle_sample); //here we actually associate the ToF sample with the proper connection handle obtained with BLE_GAP_EVT_RSSI_CHANGED event
	if (p_ctx == NULL) {
		return;
	}
	if (m_tx_ok && m_rx_ok && m_rssi_ok) {
		if (p_ctx->sample_idx < TOF_SAMPLES_TO_ACQUIRE) {
			p_ctx->buffer[p_ctx->sample_idx].connection_events_counter = m_ce_counter-1; //for some reason the connection event counter starts always from 2 and not 1....
			p_ctx->buffer[p_ctx->sample_idx].frequency_reg = m_radio_freq_sample;
			p_ctx->buffer[p_ctx->sample_idx].ifs_duration_ticks = m_rxaddress_evt_ticks_sample;
			p_ctx->buffer[p_ctx->sample_idx].rssi = m_rssi_sample;
			p_ctx->buffer[p_ctx->sample_idx].access_address = m_access_address_sample;
			p_ctx->sample_idx++;
		}
	}else{
		return;
	}
	if (p_ctx->sample_idx >= TOF_SAMPLES_TO_ACQUIRE) {
		if (p_ctx->evt_handler != NULL) {
			ifs_tof_evt_t evt;
			evt.evt_type = IFS_TOF_EVT_BUFFER_FULL;
			evt.p_ctx = p_ctx;
			p_ctx->evt_handler(&evt);	//call the application handler
		}
		p_ctx->sample_idx = 0;
		m_ce_counter = 0;
	}
}

/**
 * @brief Handler for timer events.
 */
void timer_event_handler(nrf_timer_event_t event_type, void* p_context) {
	switch (event_type) {
	case NRF_TIMER_EVENT_COMPARE3: //if the timer reach the SUPERVISION_TIMEOUT_US there may be a corrupted packet, then the sample shall be discarded
		m_rx_ok = 0;
		m_tx_ok = 0;
		m_rssi_ok = false;
		break;
	default:
		//Do nothing.
		break;
	}
}


// The EGU peripheral is configured so that the interrupt handler is called when the radio generates the EVENTS_ADDRESS. This kind of event is identical when the address is
// transmitted or received, so we use the NRF_RADIO->STATE to understand if we are dealing with a TX_EVENTS_ADDRESS or a RX_EVENTS_ADDRESS.
void EGU_IRQHandler(void) {
	nrf_egu_event_t event = nrf_egu_event_triggered_get(EGU,EGU_CHANNEL);
	if(nrf_egu_event_check(EGU, event)){
		nrf_egu_event_clear(EGU, event);

		if (m_ifs_tof_active) {
			uint32_t radio_state = NRF_RADIO->STATE;
			if (radio_state == RADIO_STATE_TX) { //radio is in TX
				m_radio_freq_sample = NRF_RADIO->FREQUENCY;
				m_tx_ok = true;
				m_ce_counter++;
			}
			if (radio_state == RADIO_STATE_RX) { //radio is in RX
				m_rxaddress_evt_ticks_sample = NRF_TIMER1->CC[0];
				if (NRF_RADIO->EVENTS_RSSIEND) { //if the rssi sample is ready store it
					m_rssi_sample = -((int32_t) NRF_RADIO->RSSISAMPLE);
					//next part was an attempt to obtain the bd_addr of the peer without using BLE_GAP_EVT_RSSI_CHANGED, for now I had no success...
					//					m_rssi_ok = true;
					//					uint8_t rxaddresses = NRF_RADIO->RXADDRESSES;
					//					uint32_t base_address;
					//					uint32_t prefix0;
					//					if(rxaddresses == 1){
					//						base_address = NRF_RADIO->BASE0 & 0xFFFFFF00;
					//						prefix0 = NRF_RADIO->PREFIX0 & 0x000000FF;
					//						m_access_address_sample = base_address + prefix0;
					//					}else{
					//						rxaddresses = 0;
					//						base_address= 0;
					//						prefix0 = 0;
					//					}
				}
				m_rx_ok = true;
			}
		}
	}
}

ret_code_t ifs_tof_get_last_sample(ifs_tof_t * p_ctx, ifs_tof_sample_t* sample){ //this function permits to access all samples, not only those related to the registered connection handle
		sample->conn_handle = m_conn_handle_sample;
		sample->connection_events_counter = p_ctx->buffer[p_ctx->sample_idx].connection_events_counter;
		sample->frequency_reg = p_ctx->buffer[p_ctx->sample_idx].frequency_reg;
		sample->ifs_duration_ticks = p_ctx->buffer[p_ctx->sample_idx].ifs_duration_ticks;
		sample->rssi = p_ctx->buffer[p_ctx->sample_idx].rssi;
		sample->access_address = m_access_address_sample;
		return NRF_SUCCESS;
}

void ifs_tof_init_struct(ifs_tof_t * p_ctx){
	p_ctx->sample_idx = 0;
	p_ctx->ce_counter = 0;
	p_ctx->evt_handler = NULL;
	p_ctx->conn_handle = BLE_CONN_HANDLE_INVALID;
}

uint32_t ifs_tof_init(ifs_tof_t * p_buff){
//TODO: implement a deinit function for releasing the resources
	uint32_t address_evt_addr, end_evt_addr;
	uint32_t address_task_addr, end_task_addr;
	nrf_ppi_channel_t ppi_channel_radio_evt_address, ppi_channel_radio_evt_end;
	ret_code_t err_code;

	// Configure the timer that will measure the ToF. It also manage the supervision timeout.
	// (NB: this supervision timeout has nothing to do with the field supervision timeout of the BLE connection parameters)
	// in this case the supervision timeout is a safety timer to invalidate the measure if the NRF_RADIO->EVENTS_ADDRESS is not generated (because of a corrupted packet)
    nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG;
    timer_cfg.bit_width = NRF_TIMER_BIT_WIDTH_32;
    timer_cfg.frequency = NRF_TIMER_FREQ_16MHz;
    timer_cfg.mode = NRF_TIMER_MODE_TIMER;
    timer_cfg.interrupt_priority = BLE_IFS_TOF_BLE_OBSERVER_PRIO;
    err_code = nrf_drv_timer_init(&TIMER, &timer_cfg, timer_event_handler);
    APP_ERROR_CHECK(err_code);
    TIMER.p_reg->EVENTS_COMPARE[3] = 0;
    uint32_t supervision_timeout_ticks = nrf_drv_timer_us_to_ticks(&TIMER, SUPERVISION_TIMEOUT_US);
    nrf_drv_timer_extended_compare(&TIMER, NRF_TIMER_CC_CHANNEL3, supervision_timeout_ticks, NRF_TIMER_SHORT_COMPARE3_STOP_MASK | NRF_TIMER_SHORT_COMPARE3_CLEAR_MASK , true);

    //Connect NRF_RADIO->EVENTS_END event to TIMER->TASKS_START so that the timer is automatically started with NRF_RADIO->EVENTS_END event
	err_code = nrf_drv_ppi_channel_alloc(&ppi_channel_radio_evt_end);
	APP_ERROR_CHECK(err_code);
	end_task_addr = (uint32_t) &(TIMER.p_reg->TASKS_START);
	end_evt_addr = (uint32_t) &(NRF_RADIO->EVENTS_END);
	err_code = nrf_drv_ppi_channel_assign(ppi_channel_radio_evt_end,end_evt_addr, end_task_addr);
	APP_ERROR_CHECK(err_code);

	//Connect NRF_RADIO->EVENTS_ADDRESS event to TIMER->TASKS_CAPTURE so that the counter value is automatically captured with NRF_RADIO->EVENTS_ADDRESS
	err_code = nrf_drv_ppi_channel_alloc(&ppi_channel_radio_evt_address);
	APP_ERROR_CHECK(err_code);
	address_evt_addr = (uint32_t)&(NRF_RADIO->EVENTS_ADDRESS);
	address_task_addr = (uint32_t) &(TIMER.p_reg->TASKS_CAPTURE[0]);
	err_code = nrf_drv_ppi_channel_assign(ppi_channel_radio_evt_address, address_evt_addr, address_task_addr);
	APP_ERROR_CHECK(err_code);

	//Connect (with a PPI fork) NRF_RADIO->EVENTS_ADDRESS event to and EGU channel so that we can read timer capture value using EGU_IRQHandler
	address_task_addr = (uint32_t)nrf_egu_task_trigger_address_get(EGU,EGU_CHANNEL);
	err_code = nrf_drv_ppi_channel_fork_assign(ppi_channel_radio_evt_address, address_task_addr);
	APP_ERROR_CHECK(err_code);

	//Enable EGU interrupt
	nrf_egu_event_clear(EGU, EGU_CHANNEL);
	nrf_egu_int_enable(EGU, nrf_egu_int_get(EGU,EGU_CHANNEL) );
    NVIC_ClearPendingIRQ(EGU_IRQn);
    NVIC_SetPriority(EGU_IRQn, BLE_IFS_TOF_BLE_OBSERVER_PRIO);
    NVIC_EnableIRQ(EGU_IRQn);

	//Enable all PPI channels used.
	err_code = nrf_drv_ppi_channel_enable(ppi_channel_radio_evt_end);
	APP_ERROR_CHECK(err_code);
	err_code = nrf_drv_ppi_channel_enable(ppi_channel_radio_evt_address);
	APP_ERROR_CHECK(err_code);

	//Assign buffer pointer
	m_p_buff = p_buff;

	//Register the SoftDevice event observer to get ble stack events
	NRF_SDH_BLE_OBSERVER(m_ifs_tof_bel_obs, BLE_IFS_TOF_BLE_OBSERVER_PRIO, ifs_tof_on_ble_evt, NULL);

	return 0;//dummy return
}

uint32_t ifs_tof_enable_module(void) {
	m_ifs_tof_active = true;
	return 0;
}

void ifs_tof_disable_module(void){
	m_ifs_tof_active = false;
}

uint32_t ifs_tof_register_conn_handle(const ble_gap_evt_t *triggering_evt, ifs_tof_evt_handler_t evt_handler) { //this can be called multiple times (on different p_ctx objects) to register more conn_handles
	ifs_tof_t * p_ctx = get_first_free_instance();
	if(p_ctx == NULL)
		return 1;

	uint32_t ret = sd_ble_gap_rssi_start(triggering_evt->conn_handle, 0, 0);
	p_ctx->evt_handler = evt_handler;
	p_ctx->conn_handle = triggering_evt->conn_handle;
	memcpy(&p_ctx->bd_address, &triggering_evt->params.connected.peer_addr, sizeof(ble_gap_addr_t));

	m_number_of_registered_conn_handles++;

	return ret;
}

uint32_t ifs_tof_unregister_conn_handle(uint16_t connection_handle){
	ifs_tof_t * p_ctx = get_instance_by_conn_handle(connection_handle);
	if(p_ctx == NULL)
		return 1;

	sd_ble_gap_rssi_stop(p_ctx->conn_handle);
	m_number_of_registered_conn_handles--;
	if( m_number_of_registered_conn_handles == 0 ){
//		m_ifs_tof_active = false;					//this is for automatically disable ifs_tof module when the amount of tracked peers is zero. In the general case it is better to let the application to decide when the module have to be disabled.
	}
	p_ctx->conn_handle = BLE_CONN_HANDLE_INVALID;
	return 0;
}

/** @}
 *  @endcond
 */
